# Fermat primality test

input data: 65

PLAN:

decrement 65
64
add ^
64^
copy number
64^64
add %
copy number
64^64##%64
@@@@@@ if left side (number on the left of the ^) is not 1; 1 -> exit (make decision), not 1 -> carry below
copy to distant place so that there is enough space for computation
64^64##%64#########################################################################################64^64##%64
apply power subroutine to the left 64^64##%64
result is 3.940201e+115##%64########################################################64^64##%64
that means power must copy to the left
than if result is one, delete the number and then go to the right till you reach the number
decrement first number (before ^)
continue with @@@@@@


2#3##~100110

accepts n
choose random a lesser than n and greater than 2

algorithm:
- start on 2
- choose probabilistic transition function - either increment or continue to modulo
 - if equal to n-1 go to modulo, otherwise increment (recursion)
 - continue to modulo
- modulo

1. write number
101011101
2. decrement it (to n-1)
3. add 2
101011101#10
4. probabilistic step - choose one of:
 - continue to modulo
 - (compare) if equal to n-1 continue to modulo, otherwise increment and run 4.

# todo spare state ลข